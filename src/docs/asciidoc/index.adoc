= Micronaut Gradle plugin
:native-build-tools-version: 0.9.6
:kotlin-version: 1.5.30
:micronaut-version: 3.1.1
:gradle-version: 7.2
:shadow-version: 7.0.0
:native-gradle-plugin: https://graalvm.github.io/native-build-tools/{native-build-tools-version}/gradle-plugin.html
:gradle-docs: https://docs.gradle.org/{gradle-version}/userguide
:gradle-toolchains: {gradle-docs}/toolchains.html
:default-docker-image: openjdk:17-alpine
:docker-plugin: https://github.com/bmuschko/gradle-docker-plugin
:aws-docs: https://micronaut-projects.github.io/micronaut-aws/latest/guide/index.html#customRuntimes

Version {gradle-project-version}

== What's new

NOTE: Documentation for the 2.x branch can be found https://github.com/micronaut-projects/micronaut-gradle-plugin/tree/2.0.x#readme[here].

The 3.0.0 version of the plugin integrates with the {native-gradle-plugin}[official GraalVM plugin] which introduces some breaking changes:

    - the `nativeImage` task is now replaced with `nativeCompile`
    - native image configuration happens in the `graalvmNative` DSL block
    - The GraalVM SDK being used depends on how you configure {gradle-toolchains}[toolchains]

Please refer to the <<native-image, native image section>> for more help: the <<toolchain-behavior,toolchain selection mechanism might be surprising to you>>.

== The Gradle plugins

A Gradle Plugin which makes development of Micronaut application and libraries a breeze.

This project currently consists of 3 plugins:

- the https://plugins.gradle.org/plugin/io.micronaut.application[`io.micronaut.application`] plugin is aimed at building Micronaut applications. It automatically integrates with GraalVM by applying the `io.micronaut.graalvm` plugin transparently.
- the https://plugins.gradle.org/plugin/io.micronaut.library[`io.micronaut.library`] plugin is aimed at building Micronaut libraries.
- the https://plugins.gradle.org/plugin/io.micronaut.graalvm[`io.micronaut.graalvm`] plugin integrates with the official {native-gradle-plugin}[GraalVM Native Build Tools plugin] and configures it for Micronaut applications.

== Quick Start

Template projects are available via https://micronaut.io/launch/[Micronaut Launch] for each language.

To get started you can use the Micronaut CLI:

[source, bash]
----
$ mn create-app demo --lang java
$ mn create-app demo --lang groovy
$ mn create-app demo --lang kotlin
----

Or if you don't have it installed via `curl`:

[source, bash]
----
# for Java
$ curl https://launch.micronaut.io/demo.zip?lang=java \
  -o demo.zip && unzip demo.zip -d demo && cd demo
# for Groovy
$ curl https://launch.micronaut.io/demo.zip?lang=groovy \
  -o demo.zip && unzip demo.zip -d demo && cd demo
# for Kotlin
$ curl https://launch.micronaut.io/demo.zip?lang=kotlin \
  -o demo.zip && unzip demo.zip -d demo && cd demo
----

== Micronaut Library Plugin

.Applying the plugin
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
  id 'io.micronaut.library' version '{gradle-project-version}'
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
  id("io.micronaut.library") version "{gradle-project-version}"
}
----

The https://plugins.gradle.org/plugin/io.micronaut.library[Micronaut library plugin] applies the following modifications to the build:

* Applies the https://search.maven.org/artifact/io.micronaut/micronaut-bom[Micronaut Bill of Materials (BOM)]
* Applies the `java-library` plugin
* Configures annotation processing for the current language (Groovy, Java or Kotlin)

The `micronaut` DSL can be used to configure how this behaves.

The minimum requirement is to set the Micronaut version to use. This can be done by setting `micronautVersion` in `gradle.properties` or as follows in `build.gradle(.kts)`:

.Selecting the Micronaut version
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
micronaut {
    version "{micronaut-version}"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
micronaut {
    version.set("{micronaut-version}")
}
----

Complete example with the default settings:

.Micronaut configuration options
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
micronaut {
    version "{micronaut-version}"
    processing {
        // Sets whether incremental annotation processing is enabled
        incremental true
        // Sets the module name.
        // This should be the same as the artifactId in the POM
        module project.name
        // Sets the group.
        // This should be th same as the groupId in the POM
        group project.group
        // Sets the Java package names containing any custom Micronaut
        // meta annotations (new annotations annotated with say @Around).
        // Generally used only for advanced cases such as defining new AOP
        // advice. If omitted however, incremental annotation processing
        // will not work correctly
        annotations "com.example.*"
        // additional sourceSets can be configured here to apply the BOM
        // and annotation processors to source sets other than 'main'
        sourceSets(
             sourceSets.main
        )
    }
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
micronaut {
    version.set("{micronaut-version}")
    processing {
        // Sets whether incremental annotation processing is enabled
        incremental.set(true)
        // Sets the module name.
        // This should be the same as the artifactId in the POM
        module.set(project.name)
        // Sets the group.
        // This should be th same as the groupId in the POM
        group.set(project.group)
        // Sets the Java package names containing any custom Micronaut
        // meta annotations (new annotations annotated with say @Around).
        // Generally used only for advanced cases such as defining new AOP
        // advice. If omitted however, incremental annotation processing
        // will not work correctly
        annotations.add("com.example.*")
        // additional sourceSets can be configured here to apply the BOM
        // and annotation processors to source sets other than 'main'
        sourceSets(
             sourceSets.findByName("main")
        )
    }
}
----

NOTE: The Micronaut Library plugin also supports Groovy and Kotlin sources.

=== Kotlin Support

For Kotlin, the Kotlin `jvm` and `kapt` plugins must be configured:

.Configuring Kotlin support
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id "org.jetbrains.kotlin.jvm" version "{kotlin-version}"
    id "org.jetbrains.kotlin.kapt" version "{kotlin-version}"
    id "io.micronaut.library" version "{gradle-project-version}"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "{kotlin-version}"
    id("org.jetbrains.kotlin.kapt") version "{kotlin-version}"
    id("io.micronaut.library") version "{gradle-project-version}"
}
----

=== Minimal Build

With the `io.micronaut.library` plugin applied a minimal build to get started writing a library for Micronaut that written in Java and is tested with JUnit 5 looks like:

.A minimal build file
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id 'io.micronaut.library' version '{gradle-project-version}'
}

version "0.1"
group "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version = "{micronaut-version}"
}

dependencies {
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id("io.micronaut.library") version "{gradle-project-version}"
}

version = "0.1"
group = "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version.set("{micronaut-version}")
}

dependencies {
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}
----

== Micronaut Application Plugin

.Applying the Micronaut Application plugin
[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
  id "io.micronaut.application" version "{gradle-project-version}"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
  id("io.micronaut.application") version "{gradle-project-version}"
}
----

The https://plugins.gradle.org/plugin/io.micronaut.application[Micronaut application plugin] extends the Micronaut Library plugin and adds the following customizations:

* Instead of the `java-library` plugin the plugin applies the Gradle `application` plugin
* Applies the `io.micronaut.graalvm` plugin
* Correctly configures Gradle for continuous build

The following additional tasks are provided by this plugin:

* `buildLayers` - Builds application layers for use in a Docker container
* `dockerfile` - Builds a Docker File for a Micronaut application
* `dockerBuild` - Builds a Docker Image using the https://github.com/bmuschko/gradle-docker-plugin[Docker Gradle plugin]
* `dockerfileNative` - Builds a Docker File for for GraalVM Native Image
* `dockerBuildNative` - Builds a Native Docker Image using GraalVM Native Image
* `nativeCompile` - Builds a GraalVM Native Image
* `testNativeImage` (since 1.1.0) - Builds a GraalVM Native Image, starts the native server and runs tests against the server
* `dockerPush` - Pushes a Docker Image to configured container registry
* `dockerPushNative` - Pushes a Docker Image built with GraalVM Native Image to configured container registry

To run an application with continuous build use the `run` task with the `-t` parameter:

[source, bash]
----
$ ./gradlew run -t
----

=== Minimal Build

With the `io.micronaut.application` plugin applied a minimal build to get started with a Micronaut server application that is written in Java and tested with JUnit 5 looks like:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id 'io.micronaut.application' version '{gradle-project-version}'
}

version "0.1"
group "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version = "{micronaut-version}"
}

dependencies {
    implementation("io.micronaut:micronaut-http-server-netty")
    runtimeOnly("ch.qos.logback:logback-classic")
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}

application {
    mainClass = "example.Application"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id("io.micronaut.application") version "{gradle-project-version}"
}

version = "0.1"
group = "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version.set("{micronaut-version}")
}

dependencies {
    implementation("io.micronaut:micronaut-http-server-netty")
    runtimeOnly("ch.qos.logback:logback-classic")
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}

application {
    mainClass.set("example.Application")
}
----

=== Kotlin Support

The most simple Kotlin build using a `build.gradle(.kts)` file looks like:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id "org.jetbrains.kotlin.jvm" version "{kotlin-version}"
    id "org.jetbrains.kotlin.kapt" version "{kotlin-version}"
    id "org.jetbrains.kotlin.plugin.allopen" version "{kotlin-version}"
    id "io.micronaut.application" version "{gradle-project-version}"
}

version "0.1"
group "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version = "{micronaut-version}"
}

dependencies {
    implementation "io.micronaut:micronaut-http-server-netty"
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:{kotlin-version}"
    implementation "org.jetbrains.kotlin:kotlin-reflect:{kotlin-version}")
    runtimeOnly "ch.qos.logback:logback-classic")
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}

application {
    mainClass = "example.ApplicationKt"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "{kotlin-version}"
    id("org.jetbrains.kotlin.kapt") version "{kotlin-version}"
    id("org.jetbrains.kotlin.plugin.allopen") version "{kotlin-version}"
    id("io.micronaut.application") version "{gradle-project-version}"
}

version = "0.1"
group = "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version.set("{micronaut-version}")
}

dependencies {
    implementation("io.micronaut:micronaut-http-server-netty")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:{kotlin-version}")
    implementation("org.jetbrains.kotlin:kotlin-reflect:{kotlin-version}")
    runtimeOnly("ch.qos.logback:logback-classic")
    testImplementation("io.micronaut.test:micronaut-test-junit5")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}

application {
    mainClass.set("example.ApplicationKt")
}
----

[[native-image]]
=== GraalVM Native Image

Since version 3.0.0, the Micronaut plugins rely on the {native-gradle-plugin}[official GraalVM plugin] to build native images.

Those plugins make use of the {gradle-toolchains}[Gradle toolchains] support, which means that the SDK which is used to build the native is decorrelated from the JVM which is used to launch Gradle itself.
Said differently, you can run Gradle with OpenJDK, while still building native images using the GraalVM SDK.

The Micronaut Gradle plugin will automatically configure the toolchains support for you, but there are a few things that you should be aware of:

- running Gradle with a GraalVM SDK doesn't necessarily imply that Gradle will use the same SDK to build native images
- Gradle will try to locate a _compatible GraalVM toolchain_ to build images. You can tweak what GraalVM version to use by following the {native-gradle-plugin}#_selecting_the_graalvm_toolchain[official documentation].

[[toolchain-behavior]]
IMPORTANT: While the toolchain selection will properly select a GraalVM SDK which matches your language version requirements, it will **not** let you pick a particular GraalVM version (say, prefer 21.3 over 21.1). If your application depends on a specific GraalVM version, you will have to disable automatic detection like explained below.

If you have several GraalVM installations available, or that you want to disable the automatic toolchain recognition, we recommend that you do the following:

- setup an environment variable named `GRAALVM_HOME` pointing to your GraalVM installation
- edit your `gradle.properties` file to add the following options:

[source, subs="verbatim"]
----
# Disable Gradle automatic download of Java SDKs
org.gradle.java.installations.auto-download=false
# Disable auto-detection of Java installations
org.gradle.java.installations.auto-detect=false
# Setup explicitly that the Java version to use
# should be the one from the JAVA_HOME environment variable
org.gradle.java.installations.fromEnv=JAVA_HOME
----

Alternatively you can pass those options from the command line:

[source, bash]
----
./gradlew -Porg.gradle.java.installations.auto-download=false \
  -Porg.gradle.java.installations.auto-detect=false \
  -Porg.gradle.java.installations.fromEnv=JAVA_HOME \
  build
----

You can build a native image by running the following task:

[source, bash]
----
$ ./gradlew nativeCompile
----

And you can run it by calling the following task:

[source, bash]
----
$ ./gradlew nativeRun
----

You can tweak the native image options by configuring the `graalvmNative` extension as explained in the {native-gradle-plugin}[plugin documentation].

For example you can add options to the main image by doing:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    binaries {
        main {
            buildArgs << "-H:-DeleteLocalSymbols"
            buildArgs << "-H:+PreserveFramePointer"
        }
    }
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
graalvmNative {
    binaries {
        named("main") {
            buildArgs.add("-H:-DeleteLocalSymbols")
            buildArgs.add("-H:+PreserveFramePointer")
        }
    }
}
----

IMPORTANT: If you update an existing Micronaut application that contains the file `src/main/resources/META-INF/native-image/xxxxx/native-image.properties`, please make sure to delete the properties `-H:Name` and `-H:Class` from the file because they are managed automatically by the plugin.

==== Build "mostly static" native images

Since GraalVM 21.0 it is possible to create "mostly static" native images that can run in a _distroless_ docker image. You only need to configure the appropriate _baseImage_ and the plugin will automatically configure GraalVM:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named('dockerfileNative') {
    baseImage('gcr.io/distroless/cc-debian10')
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<io.micronaut.gradle.docker.NativeImageDockerfile>("dockerfileNative") {
    baseImage("gcr.io/distroless/cc-debian10")
}
----

In case you want to use another base image you need to set the appropriate GraalVM flag:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named('dockerfileNative') {
    baseImage(...)
    args('-H:+StaticExecutableWithDynamicLibC')
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<io.micronaut.gradle.docker.NativeImageDockerfile>("dockerfileNative") {
    baseImage(...)
    args("-H:+StaticExecutableWithDynamicLibC")
}
----

=== Testing Native Images

NOTE: This feature is independent from the official GraalVM testing support, which actually runs a test suite _within a native image_. Micronaut native test support launches a JVM test suite _against a native image server_.

Since 1.1.x of the plugin, you can also use the `testNativeImage` task to start the Micronaut native server and run tests against it.

IMPORTANT: This feature only works in combination with `micronaut-test-core` versions 2.2.1 or above. Make sure your test classpath includes at least this version of Micronaut Test.

Using this task will replace the regular embedded server used for tests with the natively built executable:

[source, bash]
----
./gradlew testNativeImage
----

It is important to note that there are some limitations to this approach in that the native server is no longer "embedded" in the test. This has the following implications:

* It is not possible to mock components using `@MockBean` or replace beans using `@Replaces` since the native server starts in a separate process and beans injected into or defined by the test are no longer shared with the application under test since it is running in a separate process.
* The native server starts with the `test` environment active, however the classpath of the application is the runtime classpath not the test classpath. This has the implication that certain testing features (like for example Testcontainers' usage of JDBC URLs to start containers) won't work and you have to explicitly start any test containers in the test itself.

If you wish to split your native image tests from your regular tests you can {gradle-docs}/java_testing.html#sec:configuring_java_integration_tests[create an additional source set for integration tests] and the plugin will add an additional task suffixed with `*NativeImage` to run the native image tests, for example: `gradle integrationTestNativeImage`.

=== Docker Support

The Micronaut plugin includes integration with the https://bmuschko.github.io/gradle-docker-plugin[Gradle Docker plugin] allowing you to easily build applications and native images using Docker containers.

Applications are built as layered JARs using the `buildLayers` task ensuring optimized Docker images for Java applications.

To build a regular Java application into a Docker container that is ready to be deployed and exposes ports `8080` you can simply do:

[source, bash]
----
$ ./gradlew dockerBuild
----

The default uses an `{default-docker-image}` base image, however you can easily switch the base image to use by using the `baseImage` property of the `dockerfile` task:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named("dockerfile") {
  baseImage = "oracle/graalvm-ce:20.3.0-java11"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<MicronautDockerfile>("dockerfile") {
  baseImage.set("oracle/graalvm-ce:20.3.0-java11")
}
----

The above examples switches to use GraalVM CE 20.3.0 as a base image.

To build the application into a Native Image you can run:

[source,bash]
----
$ ./gradlew dockerBuildNative
----

Note that for this to work you must build the application with the same GraalVM SDK as used to build the image.

To push the container to the currently configured container registry you can use either `dockerPush` or `dockerPushNative` for the native image:

[source, bash]
----
$ ./gradlew dockerPush
----

To configure the image names to push you can use the `images` setting of the `dockerBuild` task.

For example the following configures `dockerPush` to use Oracle Container Registry:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named("dockerBuild") {
    images = ["eu-frankfurt-1.ocir.io/xyzzyz/repo/my-image:$project.version"]
}

tasks.named("dockerBuildNative") {
    images = ["eu-frankfurt-1.ocir.io/xyzzyz/repo/my-image-native:$project.version"]
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<DockerBuildImage>("dockerBuild") {
    images.add("eu-frankfurt-1.ocir.io/xyzzyz/repo/my-image:$project.version")
}

tasks.named<DockerBuildImage>("dockerBuildNative") {
    images.add("eu-frankfurt-1.ocir.io/xyzzyz/repo/my-image-native:$project.version")
}
----

Notice that you can supply two different image names to push to for the JVM version and the native version of the application.

If you wish to customize the docker builds that are used, the easiest way is to run `./gradlew dockerfile` (or `dockerfileNative` for the native version) and copy the generated `Dockerfile` from `build/docker` to your root directory and modify as required.

If you wish to customize the JVM arguments or native image arguments then it is possible to do so with the `args` method of the `dockerfile` and `dockerfileNative` tasks:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named("dockerfile") {
   args("-Xmx128m")
}
tasks.named("dockerfileNative") {
   args("-Xmx64m")
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<MicronautDockerfile>("dockerfile") {
   args("-Xmx128m")
}
tasks.named<io.micronaut.gradle.docker.NativeImageDockerfile>("dockerfileNative") {
   args("-Xmx64m")
}
----

The above configuration uses a max heap setting of `128m` for Java and `64m` for native image for the application.

To add additional docker instructions to the generated Dockerfile, such as adding a HEALTHCHECK, you can do the following. The additional instructions will be added at the end of the `Dockerfile` just before the `ENTRYPOINT`.

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named("dockerfile") {
 args("-Xmx128m")
 instruction """HEALTHCHECK CMD curl -s localhost:8090/health | grep '"status":"UP"' """
}
tasks.named("dockerfileNative") {
 args("-Xmx64m")
 instruction """HEALTHCHECK CMD curl -s localhost:8090/health | grep '"status":"UP"'"""
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
tasks.named<Dockerfile>("dockerfile") {
 args("-Xmx128m")
 instruction("""HEALTHCHECK CMD curl -s localhost:8090/health | grep '"status":"UP"' """)
}
tasks.named<io.micronaut.gradle.docker.NativeImageDockerfile>("dockerfileNative") {
 args("-Xmx64m")
 instruction("""HEALTHCHECK CMD curl -s localhost:8090/health | grep '"status":"UP"'""")
}
----

You can also add any of the other instructions/commands that the docker plugin supports, see {docker-plugin}/blob/master/src/main/groovy/com/bmuschko/gradle/docker/tasks/image/Dockerfile.groovy[the Dockerfile task documentation].

=== Micronaut Runtimes

A higher level concept of "runtimes" is included in the Micronaut Gradle plugin which essentially allows the plugin to decide which server runtime to include in the dependencies of the application when building the application. For example consider this minimal build:

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
     id 'io.micronaut.application' version '{gradle-project-version}'
}
version "0.1"
group "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version = "{micronaut-version}"
    runtime "netty"
}

dependencies {
    runtimeOnly("ch.qos.logback:logback-classic")
}

application {
    mainClass = "example.Application"
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
     id("io.micronaut.application") version "{gradle-project-version}"
}
version = "0.1"
group = "com.example"

repositories {
    mavenCentral()
}

micronaut {
    version.set("{micronaut-version}")
    runtime.set("netty")
}

dependencies {
    runtimeOnly("ch.qos.logback:logback-classic")
}

application {
    mainClass = "example.Application"
}
----

Here the only dependency declared is on the logging framework to use however `runtime` is to `netty` resulting in an application that can be built and run.

If you wish to take the same and build or run it with a different runtime you can pass the `micronaut.runtime` property for the build. For example:

[source, bash]
----
./gradlew run -Pmicronaut.runtime=google_function
----

The above example run the application as a Google Cloud Function.

The available runtimes are:

* `netty` - A Netty server runtime
* `jetty` - A Jetty server runtime
* `tomcat` - A Tomcat server runtime
* `undertow` - An Undertow server runtime
* `lambda` - Allows building the application into an AWS Lambda
* `oracle_function` - A Project.fn runtime for deploying Oracle Functions
* `google_function` - A runtime for deploying Google Functions.
* `azure_function` - A runtime for deploying Azure Functions

The advantage of allowing your dependencies to be dictated by the runtime is that you can potentially take the same application and deploy it to any of the above runtimes without changes.

==== Deploying to AWS Lambda as GraalVM native image

If you are interested in deploying your Micronaut application to AWS Lambda using GraalVM you only need to set the runtime to `lambda` and execute `./gradlew buildNativeLambda`.
This task will generate a GraalVM native image inside a Docker container and then it will create the file `build/libs/your-app.zip` file ready to be deployed to AWS Lambda using a custom runtime. See more information in {aws-docs}[Micronaut AWS documentation].

=== Packaging the application

By default the plugin doesn't create a runnable fatjar when running `./gradlew assemble`.
There are a couple of options:

==== Layered application

The plugin creates a "layered" application in `build/layers` and from that directory you can run `java -jar myapp.jar`.
It works because that directory contains a `lib` directory with all the libraries and a `resources` directory with the configuration.
Keep in mind that copying the only `.jar` file to another directory won't work.

==== Add Shadow plugin

You can add Gradle Shadow plugin so when running `./gradlew assemble` a runnable fatjar is created in `build/libs` directory.

[source, groovy, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    ...
    id "com.github.johnrengelman.shadow" version "{shadow-version}"
    ...
}
----

[source, kotlin, subs="verbatim,attributes", role="multi-language-sample"]
----
plugins {
    ...
    id("com.github.johnrengelman.shadow") version "{shadow-version}"
    ...
}
----

== Micronaut GraalVM Plugin

The https://plugins.gradle.org/plugin/io.micronaut.graalvm[Micronaut GraalVM plugin] is applied automatically by the
https://github.com/micronaut-projects/micronaut-gradle-plugin#micronaut-application-plugin[Micronaut application plugin] (see below)
and it provides tasks to generate a GraalVM native image and also creates the GraalVM `resource-config.json` automatically with all the resources from the application.

This plugin can be applied separately if you use the `application` plugin without the `io.micronaut.application` plugin (but we strongly recommend to switch to the `io.micronaut.application` plugin in this case).
